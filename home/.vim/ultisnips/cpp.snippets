snippet { "" w
{
	${VISUAL}$0
}
endsnippet
# ---
snippet if
if (${1:false}) {
	${VISUAL}${2}
}
endsnippet
snippet ifc
if (${1}${VISUAL/\s*(.*?);?\s*$/$1/}) 
endsnippet
snippet ei "" w
 else if (${1:false}) {
	${VISUAL}${2}
}
endsnippet
snippet el "" w
 else {
	${VISUAL}${1}
}
endsnippet
snippet do
do {
	${VISUAL}${2}
} while (${1:false});
endsnippet
snippet wh
while (${1:true}) {
	${VISUAL}${2}
}
endsnippet
snippet whc
while (${1}${VISUAL/\s*(.*?);?\s*$/$1/})${2:;}
endsnippet
snippet for
for (auto ${1:const & ${2:x}} : ${3:c}) {
	${VISUAL}${4}
}
endsnippet
snippet fori
for (${1:${2:size_t} ${3:i} = ${4:0}}; ${5:$3 < ${6:0}}; ${7:++$3}) {
	${VISUAL}${8}
}
endsnippet
snippet sw
switch (${1:value}) {
	${2}
}
endsnippet
snippet try
try {
	${VISUAL}${1}
}
endsnippet
snippet ct "" w
 catch (${1:...}) {
	${VISUAL}${2}
}${3}
endsnippet
# ---
snippet f
${1:void} ${2:foobar}(${3}) {
	${VISUAL}${4}
}
endsnippet
# ---
snippet cl
class ${1:FooBar} {
	${VISUAL}${2}
};
endsnippet
snippet st
struct ${1:FooBar} {
	${VISUAL}${2}
};
endsnippet
snippet en
enum ${1:FooBar} {
	${VISUAL}${2}
};
endsnippet
snippet uo
union ${1:FooBar} {
	${VISUAL}${2}
};
endsnippet
snippet ns
namespace ${1:FooBar} {
	${VISUAL}${2}
}
endsnippet
# ---
snippet nocopy
${1:name}($1 const &) = ${2:delete};
$1 & operator = ($1 const &) = $2;
endsnippet
snippet nomove
${1:name}($1 &&) = ${2:delete};
$1 & operator = ($1 &&) = $2;
endsnippet
# ---
snippet cerr
std::cerr << ${VISUAL/\s*(.*?);?\s*$/$1/}${1} << std::endl;
endsnippet
snippet clog
std::clog << ${VISUAL/\s*(.*?);?\s*$/$1/}${1} << std::endl;
endsnippet
snippet cout
std::cout << ${VISUAL/\s*(.*?);?\s*$/$1/}${1} << std::endl;
endsnippet
snippet cin
std::cin >> ${VISUAL/\s*(.*?);?\s*$/$1/}${1};
endsnippet
# ---
snippet once
#pragma once
endsnippet
# ---
snippet [] "" w
[${1:&}] (${2}) {
	${VISUAL}${3}
}
endsnippet
# ---
snippet te
template<${2:typename ${1:T}}>
endsnippet
snippet tn "" w
typename 
endsnippet
# ---
snippet #
#include ${1/^(")?.*/(?1::<)/}${1:iostream}${1/^(")?.*/(?1:":>)/}
endsnippet
# ---
snippet main
int main(${1:int argc, char * * argv}) {
	${VISUAL}${2}
}
endsnippet
# ---
snippet c
const & 
endsnippet
snippet vo
volatile 
endsnippet
snippet ce "" w
constexpr 
endsnippet
snippet mut
mutable 
endsnippet
snippet tl "" w
thread_local 
endsnippet
snippet sta
static 
endsnippet
snippet sce
static constexpr 
endsnippet
snippet si "" w
signed ${1:char }${2}
endsnippet
snippet un "" w
unsigned ${1:int }${2}
endsnippet
# ---
snippet au "" w
auto 
endsnippet
snippet i "" w
int 
endsnippet
snippet b "" w
bool 
endsnippet
snippet ch "" w
char 
endsnippet
snippet wc "" w
wchar_t 
endsnippet
snippet sh "" w
short 
endsnippet
snippet lo "" w
long 
endsnippet
snippet fl "" w
float 
endsnippet
snippet db "" w
double 
endsnippet
snippet ll "" w
long long 
endsnippet
snippet vd "" w
void ${1:* }
endsnippet
# ---
snippet s "" w
size_t 
endsnippet
snippet u64 "" w
uint64_t 
endsnippet
snippet u32 "" w
uint32_t 
endsnippet
snippet u16 "" w
uint16_t 
endsnippet
snippet u8 "" w
uint8_t 
endsnippet
snippet i64 "" w
int64_t 
endsnippet
snippet i32 "" w
int32_t 
endsnippet
snippet i16 "" w
int16_t 
endsnippet
snippet i8 "" w
int8_t 
endsnippet
# ---
snippet <<
std::ostream & operator << (std::ostream & out, ${1}) {
	${VISUAL}${2}
	return out;
}
endsnippet
snippet >>
std::istream & operator >> (std::istream & in, ${1}) {
	${VISUAL}${2}
	return in;
}
endsnippet
# ---
snippet re
return ${1}
endsnippet
snippet co
continue;
endsnippet
snippet br
break;
endsnippet
snippet th
throw 
endsnippet
# ---
snippet ca
case ${1}:
endsnippet
# ---
snippet pu
public:
	
endsnippet
snippet pr
private:
	
endsnippet
snippet pd
protected:
	
endsnippet
# ---
snippet sc "" w
static_cast<${1:type}>(${2:${VISUAL:value/\s*(.*?);?\s*$/$1/}})
endsnippet
snippet rc "" w
reinterpret_cast<${1:type}>(${2:${VISUAL:value/\s*(.*?);?\s*$/$1/}})
endsnippet
snippet dc "" w
dynamic_cast<${1:type}>(${2:${VISUAL:value/\s*(.*?);?\s*$/$1/}})
endsnippet
snippet cc "" w
const_cast<${1:type}>(${2:${VISUAL:value/\s*(.*?);?\s*$/$1/}})
endsnippet
# ---
snippet sa
static_assert(${1:${VISUAL/\s*(.*?);?\s*$/$1/}}, "${2:${1/"/\\"/g} is not true.}");
endsnippet
snippet as
assert(${1:${VISUAL/\s*(.*?);?\s*$/$1/}});
endsnippet
# ---
snippet 0 "" w
nullptr
endsnippet
snippet tr "" w
true
endsnippet
snippet fa "" w
false
endsnippet
# ---
snippet vi
virtual 
endsnippet
snippet op "" w
operator 
endsnippet
snippet in
inline 
endsnippet
# ---
snippet ti "" w
typeid(${VISUAL/\s*(.*?);?\s*$/$1/}${1})
endsnippet
snippet dt "" w
decltype(${VISUAL/\s*(.*?);?\s*$/$1/}${1})
endsnippet
snippet so "" w
sizeof(${VISUAL/\s*(.*?);?\s*$/$1/}${1})
endsnippet
snippet aa "" w
alignas(${VISUAL/\s*(.*?);?\s*$/$1/}${1})
endsnippet
snippet ao "" w
alignof(${VISUAL/\s*(.*?);?\s*$/$1/}${1})
endsnippet
# ---
snippet ts "" w
this${1:->}${2}
endsnippet
# ---
snippet fr
friend ${1:class }${2}
endsnippet
snippet us
using 
endsnippet
snippet uns
using namespace ${1:std};
endsnippet
snippet td
typedef ${1:${VISUAL:type name/\s*(.*?);?\s*$/$1/}};${2}
endsnippet
snippet et
extern 
endsnippet
snippet ex
explicit 
endsnippet
snippet ep
export 
endsnippet
snippet ne
noexcept
endsnippet
snippet df
default
endsnippet
snippet dl
delete 
endsnippet
snippet fi
final
endsnippet
snippet ov
override
endsnippet
# ---
snippet be "" w
${1:${VISUAL:v}}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet
# ---
snippet fw "" w
std::forward<${1:T}>(${VISUAL/\s*(.*?);?\s*$/$1/}${2})
endsnippet
snippet mv "" w
std::move(${VISUAL/\s*(.*?);?\s*$/$1/}${1})
endsnippet
# ---
snippet std "" w
std::
endsnippet
# ---
snippet mu "" w
make_unique<${1:type}>(${2:${VISUAL:value/\s*(.*?);?\s*$/$1/}})
endsnippet
snippet up "" w
std::unique_ptr<${1:${VISUAL:type}}>
endsnippet
snippet vec "" w
std::vector<${1:${VISUAL:type}}>
endsnippet
